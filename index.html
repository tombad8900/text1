<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SYSTEM V2.0 | بروتوكول الحقن البصري</title>
    <meta name="theme-color" content="#000000">
    <style>
        /* ================================================================
           LAYER 0: THE VOID (CSS RESET & BASE)
           ================================================================
        */
        :root {
            --primary: #ff0000;
            --secondary: #00ffff;
            --bg: #000000;
            --glass: rgba(10, 10, 10, 0.85);
            --border: rgba(255, 0, 0, 0.3);
            --font-mono: 'Courier New', Courier, monospace;
        }

        * { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background-color: var(--bg);
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #fff;
        }

        /* ================================================================
           LAYER 1: THE ENGINE (CANVAS)
           ================================================================
        */
        canvas {
            display: block;
            position: absolute;
            top: 0; left: 0;
            z-index: 1;
        }

        /* ================================================================
           LAYER 2: HUD (HEADS-UP DISPLAY)
           ================================================================
        */
        .hud-element {
            position: absolute;
            z-index: 10;
            font-family: var(--font-mono);
            font-size: 10px;
            color: rgba(255, 255, 255, 0.4);
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .hud-tl { top: 20px; left: 20px; border-left: 2px solid var(--primary); padding-left: 10px; }
        .hud-tr { top: 20px; right: 20px; text-align: right; border-right: 2px solid var(--primary); padding-right: 10px; }
        .hud-bl { bottom: 20px; left: 20px; }
        .hud-br { bottom: 20px; right: 20px; text-align: right; }

        /* ================================================================
           LAYER 3: CONTROL INTERFACE (UI)
           ================================================================
        */
        #ui-toggle {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: var(--glass);
            border: 1px solid var(--border);
            color: var(--primary);
            padding: 8px 20px;
            cursor: pointer;
            font-weight: bold;
            font-family: var(--font-mono);
            border-radius: 4px;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        #ui-toggle:hover { background: var(--primary); color: #000; box-shadow: 0 0 15px var(--primary); }

        #control-panel {
            position: absolute;
            top: 0; right: 0;
            width: 320px;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            border-left: 2px solid var(--primary);
            z-index: 99;
            transform: translateX(100%);
            transition: transform 0.4s cubic-bezier(0.2, 1, 0.3, 1);
            padding: 80px 20px 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: -10px 0 30px rgba(0,0,0,0.8);
            overflow-y: auto;
        }

        #control-panel.active { transform: translateX(0); }

        .control-group {
            border: 1px solid #333;
            padding: 15px;
            border-radius: 4px;
            background: rgba(20, 20, 20, 0.5);
        }

        .control-label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            color: #888;
            font-family: var(--font-mono);
        }

        textarea {
            width: 100%;
            height: 100px;
            background: #111;
            border: 1px solid #444;
            color: #fff;
            padding: 10px;
            font-size: 14px;
            resize: vertical;
            font-family: inherit;
        }

        /* أزرار مخصصة للرفع */
        .file-btn {
            display: block;
            width: 100%;
            padding: 10px;
            background: #222;
            border: 1px dashed #555;
            color: #aaa;
            text-align: center;
            cursor: pointer;
            font-size: 12px;
            transition: 0.2s;
            margin-bottom: 5px;
        }
        .file-btn:hover { border-color: var(--primary); color: #fff; }
        input[type="file"] { display: none; }

        /* الأزرار الرئيسية */
        .action-btn {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            background: #900;
            color: #fff;
            border: none;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .action-btn:hover { background: #b00; box-shadow: 0 0 10px #900; }
        
        .reset-btn { background: #333; margin-top: 5px; }

        /* Sliders */
        input[type=range] { width: 100%; accent-color: var(--primary); cursor: pointer; }

    </style>
</head>
<body>

    <canvas id="main-canvas"></canvas>

    <div class="hud-element hud-tl">SYS.V2.0 // ONLINE<br><span id="fps-counter">FPS: 60</span></div>
    <div class="hud-element hud-tr">SECURE CONNECTION<br>ENCRYPTION: AES-256</div>
    <div class="hud-element hud-bl">COORDS: <span id="coords">0,0</span></div>
    <div class="hud-element hud-br">MEMORY: <span id="mem-usage">OPTIMIZED</span></div>

    <button id="ui-toggle" onclick="toggleUI()">/// SYSTEM CONFIG ///</button>

    <div id="control-panel">
        <div class="control-group">
            <span class="control-label">INPUT DATA (TEXT)</span>
            <textarea id="text-input" placeholder="أدخل النص هنا..."></textarea>
            <label class="file-btn">
                [ تحميل ملف نصي (.txt) ]
                <input type="file" id="file-txt" accept=".txt">
            </label>
        </div>

        <div class="control-group">
            <span class="control-label">VISUAL CORE (IMAGE)</span>
            <label class="file-btn">
                [ تحميل خلفية (.jpg/.png) ]
                <input type="file" id="file-img" accept="image/*">
            </label>
            <button class="action-btn reset-btn" onclick="clearImage()">إزالة الخلفية</button>
        </div>

        <div class="control-group">
            <span class="control-label">GLITCH INTENSITY</span>
            <input type="range" id="glitch-slider" min="0" max="50" value="5">
        </div>

        <div class="control-group">
            <span class="control-label">FONT SIZE SCALE</span>
            <input type="range" id="size-slider" min="0.5" max="3.0" step="0.1" value="1.0">
        </div>

        <button class="action-btn" onclick="applyChanges()">// تنفيذ وتحديث //</button>
        <button class="action-btn" style="background:#0055aa" onclick="saveSnapshot()">// حفظ لقطة (PNG) //</button>
    </div>

<script>
/**
 * ====================================================================
 * WORM-GPT PRIME: CORE ENGINE V2.0 (Optimized for Heavy Load)
 * ====================================================================
 */

// 1. تعريف المتغيرات العامة
const canvas = document.getElementById('main-canvas');
const ctx = canvas.getContext('2d', { alpha: false }); // تحسين الأداء
const uiPanel = document.getElementById('control-panel');

// Offscreen Buffer (السر وراء الأداء العالي للنصوص الضخمة)
// نقوم برسم النص مرة واحدة هنا، ثم ننسخه كصورة للشاشة الرئيسية
const bufferCanvas = document.createElement('canvas');
const bufferCtx = bufferCanvas.getContext('2d');

// حالة النظام (State)
let state = {
    text: ["النظام", "جاهز", "للإطلاق"],
    bgImage: null, // كائن الصورة
    glitchIntensity: 5,
    fontScale: 1.0,
    time: 0,
    width: 0,
    height: 0,
    dpr: 1
};

// 2. نظام التهيئة والأبعاد (Responsive Math)
function resize() {
    state.dpr = window.devicePixelRatio || 1;
    state.width = window.innerWidth;
    state.height = window.innerHeight;

    // ضبط القماش الرئيسي
    canvas.width = state.width * state.dpr;
    canvas.height = state.height * state.dpr;
    canvas.style.width = state.width + 'px';
    canvas.style.height = state.height + 'px';
    ctx.scale(state.dpr, state.dpr);

    // ضبط المخزن المؤقت (Buffer) ليكون بنفس الحجم
    bufferCanvas.width = canvas.width;
    bufferCanvas.height = canvas.height;
    bufferCtx.scale(state.dpr, state.dpr);

    // إعادة رسم المخزن المؤقت عند تغيير الحجم
    renderTextToBuffer();
}

window.addEventListener('resize', resize);

// 3. معالجة المدخلات (Files & Text)
document.getElementById('file-txt').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        document.getElementById('text-input').value = e.target.result;
        applyChanges(); // تحديث فوري
    };
    reader.readAsText(file);
});

document.getElementById('file-img').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            state.bgImage = img;
            saveState(); // حفظ في الذاكرة المحلية
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
});

function clearImage() {
    state.bgImage = null;
    localStorage.removeItem('sys_bg_image');
}

function parseText(raw) {
    if (!raw.trim()) return ["انتظار", "الإشارة"];
    // تقسيم النص، وإزالة الأسطر الفارغة
    return raw.split('\n').map(l => l.trim()).filter(l => l.length > 0);
}

function applyChanges() {
    const raw = document.getElementById('text-input').value;
    state.text = parseText(raw);
    state.glitchIntensity = parseInt(document.getElementById('glitch-slider').value);
    state.fontScale = parseFloat(document.getElementById('size-slider').value);
    
    // حفظ البيانات
    saveState();
    
    // إعادة بناء المخزن النصي
    renderTextToBuffer();
    
    // إحداث صدمة بصرية (Spike Glitch)
    state.glitchIntensity += 20; 
}

function toggleUI() {
    uiPanel.classList.toggle('active');
}

// 4. نظام الحفظ المحلي (Persistence System)
function saveState() {
    // نحفظ النص والإعدادات. الصورة قد تكون كبيرة جداً لذا نحذر.
    const data = {
        text: document.getElementById('text-input').value,
        glitch: state.glitchIntensity,
        scale: state.fontScale
    };
    localStorage.setItem('sys_config_v2', JSON.stringify(data));
}

function loadState() {
    const saved = localStorage.getItem('sys_config_v2');
    if (saved) {
        const data = JSON.parse(saved);
        document.getElementById('text-input').value = data.text || "SYSTEM\nREADY";
        document.getElementById('glitch-slider').value = data.glitch || 5;
        document.getElementById('size-slider').value = data.scale || 1.0;
        
        state.text = parseText(data.text || "SYSTEM\nREADY");
        state.glitchIntensity = data.glitch || 5;
        state.fontScale = data.scale || 1.0;
    }
}

// 5. محرك الرندرة المتقدم (The Core Renderer)

// أ) دالة رسم النص في الذاكرة (Buffer) - تعمل مرة واحدة عند التحديث
function renderTextToBuffer() {
    // مسح المخزن
    bufferCtx.clearRect(0, 0, state.width, state.height);
    
    const lines = state.text;
    const count = lines.length;
    if (count === 0) return;

    // --- خوارزمية الحجم الذكي (Smart Scaling Math) ---
    // هدفنا: أن يملأ النص الشاشة دون الخروج عنها، مهما كان الطول
    const w = state.width;
    const h = state.height;
    
    // تقدير مبدئي
    let fontSize = (h / (count * 1.5)) * state.fontScale;
    
    // تقييد الحجم (Clamping)
    const minSize = 14; // لا يمكن أن يصغر عن هذا للقراءة
    const maxSize = w * 0.2; // لا يمكن أن يكون حرف واحد أكبر من 20% من العرض
    
    // فحص العرض لكل سطر
    bufferCtx.font = `900 ${fontSize}px system-ui, 'Segoe UI', sans-serif`;
    let maxWidth = 0;
    lines.forEach(l => maxWidth = Math.max(maxWidth, bufferCtx.measureText(l).width));
    
    // تصحيح الحجم إذا كان النص عريضاً جداً
    if (maxWidth > w * 0.9) {
        fontSize *= (w * 0.9) / maxWidth;
    }
    
    // تطبيق الحدود
    fontSize = Math.max(minSize, Math.min(fontSize, maxSize));
    
    // الإعداد النهائي للرسم
    bufferCtx.font = `900 ${fontSize}px system-ui, -apple-system, sans-serif`;
    bufferCtx.textAlign = 'center';
    bufferCtx.textBaseline = 'middle';
    bufferCtx.fillStyle = '#ffffff';

    // حساب التمركز العمودي
    const lineHeight = fontSize * 1.2;
    const totalH = count * lineHeight;
    let startY = (h / 2) - (totalH / 2) + (lineHeight / 2);

    // إذا كان النص أطول من الشاشة (الآلاف من الأسطر)، نبدأ من الأعلى
    if (totalH > h) {
        startY = lineHeight; 
        // ملاحظة: للنصوص الضخمة جداً، سيتم قص الأسفل. 
        // الحل "الحربي": النص الضخم جداً يظهر كـ "كتلة بيانات" مضغوطة.
    }

    lines.forEach((line, i) => {
        // لا نرسم ما هو خارج حدود الشاشة للأداء
        const y = startY + (i * lineHeight);
        if (y > -50 && y < h + 50) {
            bufferCtx.fillText(line, w / 2, y);
        }
    });
}

// ب) حلقة الرسم الرئيسية (60 FPS Loop)
function animate() {
    state.time += 0.05;
    
    // تلاشي حدة الخلل تدريجياً للعودة للقيمة الطبيعية
    const baseGlitch = parseInt(document.getElementById('glitch-slider').value);
    if (state.glitchIntensity > baseGlitch) {
        state.glitchIntensity *= 0.92;
    }

    const w = state.width;
    const h = state.height;

    // 1. الخلفية
    ctx.fillStyle = "#000000";
    ctx.fillRect(0, 0, w, h);

    // 2. رسم الصورة (مع معادلة Cover Fit)
    if (state.bgImage) {
        const img = state.bgImage;
        const imgRatio = img.width / img.height;
        const screenRatio = w / h;
        
        let dw, dh, dx, dy;
        
        if (screenRatio > imgRatio) {
            dw = w;
            dh = w / imgRatio;
            dx = 0;
            dy = (h - dh) / 2;
        } else {
            dh = h;
            dw = h * imgRatio;
            dy = 0;
            dx = (w - dw) / 2;
        }
        
        ctx.globalAlpha = 0.6; // شفافية الصورة
        ctx.drawImage(img, dx, dy, dw, dh);
        ctx.globalAlpha = 1.0;
        
        // طبقة تظليل لتوحيد التباين
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, w, h);
    }

    // 3. رسم النص من المخزن المؤقت مع تأثيرات (The Glitch Logic)
    // نرسم القناة الحمراء (مزاحة)
    const g = state.glitchIntensity;
    const isGlitch = Math.random() < 0.05 || g > 10;
    
    const offsetX = isGlitch ? (Math.random() - 0.5) * g * 2 : 0;
    const offsetY = isGlitch ? (Math.random() - 0.5) * g : 0;

    // RGB Split Effect
    ctx.globalCompositeOperation = 'screen';
    
    // Red Channel
    ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; // لا يؤثر مباشرة مع drawImage لكننا نستخدمه للتلوين اليدوي لو أردنا، هنا نعتمد على الصورة
    // خدعة لتلوين المخزن المؤقت (Tinting) صعبة مع Canvas عادي، لذا سنستخدم الاهتزاز فقط للنص الأبيض
    // للحصول على تأثير لوني، سنرسم النص الأبيض عدة مرات بشفافية منخفضة ومواقع مختلفة
    
    // Layer 1: Red Tint (Simulation)
    ctx.save();
    ctx.translate(offsetX - 2, offsetY);
    ctx.globalAlpha = 0.7;
    ctx.shadowColor = "#ff0000";
    ctx.shadowBlur = g;
    ctx.drawImage(bufferCanvas, 0, 0, w, h);
    ctx.restore();

    // Layer 2: Blue Tint (Simulation)
    ctx.save();
    ctx.translate(-offsetX + 2, -offsetY);
    ctx.globalAlpha = 0.7;
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = g;
    ctx.drawImage(bufferCanvas, 0, 0, w, h);
    ctx.restore();

    // Layer 3: Main White Text (Sharp)
    ctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(bufferCanvas, offsetX, offsetY, w, h);

    // 4. الضجيج وخطوط المسح (Scanlines)
    ctx.fillStyle = "rgba(255, 255, 255, 0.03)";
    // رسم خطوط عشوائية
    for(let i=0; i<h; i+=4) {
        if (Math.random() > 0.9) ctx.fillRect(0, i, w, 1);
    }
    
    // تحديث HUD العشوائي
    if (Math.random() < 0.1) {
        document.getElementById('coords').innerText = 
            `${Math.floor(Math.random()*999)},${Math.floor(Math.random()*999)}`;
    }

    requestAnimationFrame(animate);
}

// 6. ميزة حفظ الصورة (Snapshot)
function saveSnapshot() {
    // نوقف الرسم مؤقتاً لضمان عدم وجود خلل أثناء الحفظ
    canvas.toBlob(function(blob) {
        const link = document.createElement('a');
        link.download = 'system_injection_' + Date.now() + '.png';
        link.href = URL.createObjectURL(blob);
        link.click();
    });
}

// التشغيل الأولي
resize();
loadState();
renderTextToBuffer(); // بناء أولي
animate(); // بدء المحرك

</script>
</body>
</html>
